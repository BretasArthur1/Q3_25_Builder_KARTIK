/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedClaimCollateralInstruction,
  type ParsedCloseCycleInstruction,
  type ParsedCreateCycleInstruction,
  type ParsedExitCycleInstruction,
  type ParsedJoinCycleInstruction,
  type ParsedSubmitContributionInstruction,
  type ParsedTriggerPayoutInstruction,
} from '../instructions';

export const ROTOFI_PROGRAM_ADDRESS =
  'GJ5q57HjkpunV17fqXQ2evLbWeCgnEWxKiqM4syPB4Dp' as Address<'GJ5q57HjkpunV17fqXQ2evLbWeCgnEWxKiqM4syPB4Dp'>;

export enum RotofiAccount {
  CycleAccount,
  MemberAccount,
  OrganizerAccount,
}

export function identifyRotofiAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): RotofiAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([229, 25, 75, 221, 155, 111, 145, 44])
      ),
      0
    )
  ) {
    return RotofiAccount.CycleAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([173, 25, 100, 97, 192, 177, 84, 139])
      ),
      0
    )
  ) {
    return RotofiAccount.MemberAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([68, 201, 38, 125, 135, 112, 11, 149])
      ),
      0
    )
  ) {
    return RotofiAccount.OrganizerAccount;
  }
  throw new Error(
    'The provided account could not be identified as a rotofi account.'
  );
}

export enum RotofiInstruction {
  ClaimCollateral,
  CloseCycle,
  CreateCycle,
  ExitCycle,
  JoinCycle,
  SubmitContribution,
  TriggerPayout,
}

export function identifyRotofiInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): RotofiInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([55, 78, 194, 172, 196, 18, 230, 252])
      ),
      0
    )
  ) {
    return RotofiInstruction.ClaimCollateral;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([230, 120, 116, 239, 41, 4, 44, 103])
      ),
      0
    )
  ) {
    return RotofiInstruction.CloseCycle;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([230, 206, 158, 192, 122, 193, 246, 254])
      ),
      0
    )
  ) {
    return RotofiInstruction.CreateCycle;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([43, 137, 185, 10, 174, 159, 14, 175])
      ),
      0
    )
  ) {
    return RotofiInstruction.ExitCycle;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([49, 71, 250, 52, 222, 37, 47, 157])
      ),
      0
    )
  ) {
    return RotofiInstruction.JoinCycle;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([123, 132, 230, 253, 141, 22, 214, 91])
      ),
      0
    )
  ) {
    return RotofiInstruction.SubmitContribution;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([145, 81, 98, 96, 194, 251, 69, 38])
      ),
      0
    )
  ) {
    return RotofiInstruction.TriggerPayout;
  }
  throw new Error(
    'The provided instruction could not be identified as a rotofi instruction.'
  );
}

export type ParsedRotofiInstruction<
  TProgram extends string = 'GJ5q57HjkpunV17fqXQ2evLbWeCgnEWxKiqM4syPB4Dp',
> =
  | ({
      instructionType: RotofiInstruction.ClaimCollateral;
    } & ParsedClaimCollateralInstruction<TProgram>)
  | ({
      instructionType: RotofiInstruction.CloseCycle;
    } & ParsedCloseCycleInstruction<TProgram>)
  | ({
      instructionType: RotofiInstruction.CreateCycle;
    } & ParsedCreateCycleInstruction<TProgram>)
  | ({
      instructionType: RotofiInstruction.ExitCycle;
    } & ParsedExitCycleInstruction<TProgram>)
  | ({
      instructionType: RotofiInstruction.JoinCycle;
    } & ParsedJoinCycleInstruction<TProgram>)
  | ({
      instructionType: RotofiInstruction.SubmitContribution;
    } & ParsedSubmitContributionInstruction<TProgram>)
  | ({
      instructionType: RotofiInstruction.TriggerPayout;
    } & ParsedTriggerPayoutInstruction<TProgram>);
